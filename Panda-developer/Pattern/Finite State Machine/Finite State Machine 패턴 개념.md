### 목적
1. 행동 모드의 명시적 관리
	- 한 순간에 하나의 상태만 활성화한다.
	- 허용된 전이만 발생하도록 한다.
	- 예측 가능하고 유지보수 가능한 로직을 만들도록 한다.
2. 복잡한 분기 로직의 구조화
	- if/else, switch/case 를 이용해 상태 단위로 분해하여 유지보수성, 가독성을 높인다.
3. 타이밍, 연속 제약의 안정적 표현
	- OnEnter/ OnUpdate/ OnExit 와 전이 조건을 바탕으로 쿨다운, Lock, 타이머 같은 연속성 규칙을 다룬다.
4. 테스트, 디버깅, 확장 용이
	- 새 상태의 추가는 적은 범위의 수정으로 가능하다.

---

### 핵심 구성 요소
##### <mark style="background: #ADCCFFA6;">HandleInput(Event)</mark>
- 전이 판단
- 필요 시 다음 상태 반환/ 전이 요청

##### <mark style="background: #ADCCFFA6;">OnEnter() / OnExit()</mark>
- 자원, Lock, Effect 등 모드 전환 처리

##### <mark style="background: #ADCCFFA6;">Update(DeltaTime)</mark>
- 시간 기반 로직
- 이동, 쿨다운, 타이머, 판정창 등
- 
---
### 핵심 개념
##### 상태
- 개체의 행동
- 예) Idle, Walking, Running, Startup, Active 등등

##### event / input
- 전이를 유발하는 입력 값
- 예) 키 입력, 타이머 만료, 충돌, Anim notify, hp 임계점 도달 등

##### 전이
한 상태에서 다른 상태로 바뀌는 과정

##### 가드
- 전이의 진입 조건
- 사거리, 각도, 쿨다운, 자원 등에 대한 조건을 확인한다.

##### 액션
- 전이 순간 또는 상태 진입/ 유지/ 이탈 에서 수행되는 작업
- **OnEnter**
	- 상태 진입 시 1회 실행
	- 그래픽 교체, 히트박스 ON, Lock 부여 등
- **OnUpdate/Tick**
	- 상태 유지 중 반복 실행
	- 이동 적분, 타이머 감소 등
- **OnExit**
	- 상태 이탈 시 1회 실행
	- Lock 해제, 히트박스 OFF 등

##### 단일 활성 불변식
- 동시에 둘 이상의 상태가 활성화되지 않는 것을 뜻한다.

---

### 프로젝트 규모에 따른 구현 전략
- 규모가 작을 때
	- enum + switch
- 규모가 클 때
	- 상태 클래스로 분리 (상태 패턴)
	- OnEnter/Update/OnExit/HandleInput
- 규모가 매우 커질 때
	- BT + FSM
	- BT는 우선순위를 고려한 다음 상태 선택, FSM는 조건을 고려한 실행 담당

---

### 사용 예시
**캐릭터 컨트롤**
이동 모드, 점프, 공격, 회피 등의 동작에 대한 상태 전이 관리

**AI 행동**
BT : Patrol, Chase, Attack, Flee 의 상위 선택 
FSM : 공격 내부 `Startup -> Active -> Recovery`

**보스 패턴**
페이즈 전환 트리거 + 기술 상태 파이프라인

**UI흐름**
화면 전환 상태, 입력 허용/차단 타이밍, 애니 완료 후 전이

---

### 주의 사항
- 프레임당 다중 Update
- 숨은 전이 (전이 지점을 단일화 하자)
- OnEnter/ Exit 누락
	- 락/ 리소스 해제 빠뜨리면 상태 누수 발생(영구 무적, 영구 락 등)
- BT, FSM 중복 소유
	- 동일 모드 정보를 두 시스템이 각각 관리하면 디싱크 위험, 단일 소스 원칙