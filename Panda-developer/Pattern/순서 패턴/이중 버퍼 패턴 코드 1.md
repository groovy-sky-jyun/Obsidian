### 그래픽스 외 사용법
이번에는 상태를 변경하는 객체가 다른 상태 변경 중인 객체의 상태값을 읽는 예시를 살펴보자. 

유닛A, 유닛B, 유닛C가 있고 각각은 다음과 같은 조건을 만족할 경우 새로운 랜덤 위치로 이동한다.
- unitA : 외부 입력으로 unitC가 선택됐으면 이동
- unitB : 외부 입력으로 unitA가 선택됐으면 이동
- unitC : 외부 입력으로 unitB가 선택됐으면면 이동

---

#### Unit Class
```cpp title:Unit
struct UnitState{
	FVector location;
	bool isChosen = false;
};

using UnitStateBuffer = std::unordered_map<Unit*, UnitState>;

class Unit{ 
public:
	Unit() {}
	virtual ~Unit() {}
	virtual void update(const UnitStateBuffer& frontBuffer, UnitStateBuffer& backBuffer) = 0;
};
```
- Unit이 가지는 속성을 struct에 담아준다.
- map을 통해 Unit과 속성(UnitState)을 짝지어 준다.
- Unit Interface를 통해 모든 Unit이 update() 함수를 구현하도록 한다.

<br>

#### UnitA/B/C
```cpp title:UnitA hl:9,13
class UnitA : public Unit{
public:      
	void setRelatedUnit(Unit* relatedUnit){
		relatedUnit_ = relatedUnit
	}

	virtual void update(const UnitStateBuffer& frontBuffer, UnitStateBuffer& backBuffer){
		// 즉각 반영 상태값 -> backBuffer
		if(backBuffer.at(relatedUnit_).isChoisen){
			backBufferr.at(this).location = /*New Location*/
		} 
		// 확정 상태값 -> frontBuffer
		else if(frontBuffer.at(...).value){
			...
		}
		// 상태 변경 없을 경우
		else{
			backBuffer.at(this).location = /*Current Location*/
		}
	}
	
private:
	Unit* relatedUnit_;
}
```
- **setRelatedUnit**
	- 특정 유닛의 상태에 따라 해당 유닛의 이동이 결정되는데, 그 특정 유닛을 지정해준다.
- **update**
	- 조건을 설정하고, 조건이 만족되면 위치를 새로운 위치로 업데이트한다.
	- 조건을 만족하지 않으면 현재 위치를 그대로 넘겨준다.
	- line:9-15 와 관련된 내용은 가장 밑의 **지연문제** 구간을 확인하자.

<br>

#### Stage Class
```cpp title:Stage
class Stage{ 
public: 
	void add(Unit* unit){
		units_.push_back(unit);
		frontBuffer_[unit] = {};
		backBuffer_[unit] = {};
	}

	void addChoiceUnit(Unit* unit){
		chosenUnitsThisTurn_.add(unit);
	}
	
	void update(){
		// 1. 상태 업데이트
		for(Unit* unit : chosenUnitsThisTurn_){
			backBuffer_[unit].isChosen = true;
		}
		// 2. 상태 반영 -> backBuffer 업데이트
		for(Unit* unit : units_){
			unit->update(frontBuffer_, backBuffer_);
		}
		// 3. 읽기용 = 이번 턴의 업데이트된 데이터
		frontBuffer_.swap(backBuffer_);

		chosenUnitsThisTurn_.clear;
	}
	
private:
	std::vector<Unit*> units_;
	UnitStateBuffer frontBuffer_; //읽기용
	UnitStateBuffer backBuffer_; //쓰기용
	std::vector<Unit*> chosenUnitsThisTurn_;
}
```
이중 버퍼 패턴의 핵심이 되는 클래스로 유닛이 움직이는 무대를 나타낸다.
총 3가지 단계를 통해 유닛들의 상태가 업데이트 된다.

1. **addChoiceUnit**
	1. 해당 턴에서 선택된 유닛들을 추가한다. (지난 턴이 아닌 이번 턴 상태 반영)
2. **update**
	1. backBuffer, frontBuffer를 바탕으로 unit의 위치를 업데이트한다.
3. **swap**
	1. 모든 유닛의 업데이트가 완료되었으므로 해당 데이터들을 읽기용 버퍼에 넘겨준다. 
	2. 외부 시스템은 frontBuffer(읽기용) 값만 읽는다.

이처럼 상태 업데이트, 상태 반영, swap을 분리하여 실행시킴으로써, 테어링 문제를 방지할 수 있다.
외부 시스템은 frontBuffer에만 접근이 가능하므로 업데이트 중인 데이터(backBuffer)에 접근할 수 없다. 

<br>

#### Main 실행 예시
```cpp
int main(){
	State stage;
	
	Unit* unitA = new Unit();
	Unit* unitB = new Unit();
	Unit* unitC = new Unit();
	
	unitA->setRelatedUnit(unitC);
	unitB->setRelatedUnit(unitA);
	unitC->setRelatedUnit(unitB);
	
	stage.add(unitA);
	stage.add(unitB);
	stage.add(unitC);

	stage.addChoiceUnit(unitA);
	stage.addChoiceUnit(unitC);

	stage.update();

	stage.addChoiceUnit(unitB);
	stage.addChoiceUnit(unitC);

	stage.update();
};
```

---

#### 문제 상황
>**지연 문제**
> 이중 버퍼의 주요 핵심은 유닛의 상태 업데이트가 끝난 확정된 상태를 읽는것이다.
> 이에 맞게 구현하려면 유닛이 이동 조건이 충족되었는지 확인할 때, `frontBuffer`를 읽어야 한다. (이전 턴에서 확정된 값이기 때문)
> 
> 이렇게 했을 때 첫번째 시작 턴을 생각해보자. 
> 플레이어는 a,c 유닛을 선택했는데 frontbuffer는 비어있으므로 아무도 안움직이게 된다.
> 이는 한 프레임 지연이 되는 문제를 불러일으킨다.
> <br>
>**발생 이유**
> 이러한 문제가 발생하는 이유는 해당 기능에서 확인하는 조건이  즉각적으로 반응해야 하는 상태이기 때문이다. 
> 다른 환경 상태 등은 이전 턴의 확정된 데이터를 반영해도 되지만, 선택 여부는 이번 턴의 상태를 반영해야 한다.
> <br>
> **해결 방법**
> 즉각적으로 반응해야 하는 상태 값일 경우 stage 클래스에서 따로 관리를 해준다.
> update가 호출되었을 때, 즉각적으로 반응하는 상태를 backBuffer에 한번에 업데이트 시켜준다. 그런 뒤, backBuffer를 통해 상태에 접근한다.
>
> 확정된 값을 사용해야 할 경우, 이전 턴의 확정값을 가지고 있는 frontBuffer를 이용한다. 
> ```cpp
> void Stage::update(){
>	for(Unit* unit : chosenUnitsThisTurn_){
>		backBuffer_[unit].isChosen = true;
>	}
>
>	for(Unit* unit : units_){
>		unit->update(frontBuffer_, backBuffer_);
>	}
>	...
>};
>
>void UnitA::update(const UnitStateBuffer& frontBuffer, UnitStateBuffer& backBuffer){
>	// 즉각적으로 반영
>	if(backBuffer.at(relatedUnit_).isChoisen){...}
>	
>	// 확정 값 반영
>	else if(frontBuffer.at(...).value){...}
>}
> ```
