### 그래픽스 외 사용법
이번에는 상태를 변경하는 코드가 다른 변경하려는 상태를 읽는 경우에 대해 알아보자.

유닛A, 유닛B, 유닛C가 있고 각각은 다음과 같은 조건을 만족할 경우 새로운 랜덤 위치로 이동한다.
- unitA : 외부 입력으로 unitC가 선택됐으면 이동
- unitB : 외부 입력으로 unitA가 선택됐으면 이동
- unitC : 외부 입력으로 unitB가 선택됐으면면 이동

#### Unit Class
```cpp title:Unit
class Unit{ 
public:
	Unit() : currentLocation_(0,0,0){}
	virtual ~Unit();
	virtual void update() = 0;
	
	void swap(){
		currentLocation_ = nextLocation_;
		IsChoices = false;
	}
	
	void setNextLocation(conast FVector& newLocation){
		nextLocation_ = newLocation;
	}

	void setIsChoices() {
		IsChoices = true;
	}

	bool getIsChoices(){
		return IsChoices;
	}
	
private:
	FVector currentLocation;
	FVector nextLocation;
	bool IsChoices = false;
};
```
유닛이 공통적으로 가지는 것들을 모아 Unit 클래스에 작성하였다.
- **swap**
	- `currentLocation_`를 `nextLocation_`값으로 업데이트 해준다.
- **wasMovedThisTurn**
	- 움직였는지를 반환한다.
- **setNextLocation**
	- `nextLocation_`를 새 위치로 업데이트 해준다.

#### Units 
```cpp title:UnitA
class UnitA : public Unit{
public:  
	void setRelatedUnit(Unit* relatedUnit){
		relatedUnit_ = relatedUnit;
	}
	
	virtual void update() override {
		if(relatedUnit_ && relatedUnit_()->getIsChoices()){
			setNextLocation(/*NewLocation*/);
		}
		else{
			setNextLocation(currentLocation);
		}
	}

private:
	Unit* relatedUnit_;
}
```
- Unit클래스를 상속받는다.
- **setRelatedUnit**
	- 이동 조건에는 특정 유닛의 이동 여부가 들어가는데 그 특정 유닛을 설정하는 함수이다.
- **update**
	- 조건을 설정하고, 조건이 만족되면 위치를 새로운 위치로 업데이트한다.
	- 조건을 만족하지 않으면 현재 위치를 그대로 넘겨준다.

#### Stage Class
```cpp title:Stage hl:9,12
class Stage{ 
public: 
	void add(Unit* unit, int index){
		units_[index] = unit
	}
	
	void update(){
		for(int i = 0; i < NUM_UNITS; i++){
			units_[i]->update();
		}
		for(int i = 0; i < NUM_UNITS; i++){
			units_[i]->swap();
		}
	}

	void StartStage(Unit* unit){
		unit->setNextLocation();
		update();
	}
	
private:
	static const int NUM_UNITS = 3;
	Unit* units_[NUM_UNITS];
}
```
유닛이 움직이는 무대를 나타내는 클래스이다.
- **add**
	- 유닛을 등록한다.
- **update**
	- 이중 버퍼 패턴의 핵심 부분이다.
	- **units_[i]->update()**
		- 각 유닛의 이동 조건 만족 여부에 따라 이동 여부를 정한다. 
		- 조건이 만족되면 `nextLocation`에는 새로운 위치들이 할당된다.
		- `bIsMoved` 값이 true이다.
**swap**
	- `currentLocation_`에 `nextLocation_`값을 할당해준다.
	- 외부시스템은 `currentLocation_`값만 읽는다. 
	- update와 swap을 분리해놓고 순차적으로 실행시킴으로써 외부 시스템은 값 변경이 전부 실행된 값을 읽을 수 있게 된다.

#### Main 실행 예시
```cpp
int main(){
	State stage;
	
	Unit* unitA = new Unit();
	Unit* unitB = new Unit();
	Unit* unitC = new Unit();

	unitA->setRelatedUnit(C);
	unitB->setRelatedUnit(A);
	unitC->setRelatedUnit(B);

	unitA->setIsChoices();
	unitB->setIsChoices();
	unitC->setIsChoices();

	stage.add(unitA, 0);
	stage.add(unitB, 1);
	stage.add(unitC, 2);

	stage.StartStage(unitC);
};
```
`unitC->setNextLocation()`을 먼저 해주는 이유는 C를 먼저 해주어야 A가 이동하는 조건이 달성되기 때문이다.

---

### 문제점
이 코드를 보면 불편한 부분이 하나 있을것이다.
유닛들의 이동 순서를 직접 지정해줘야 하는 부분말이다. (`stage.add(Unit*, int); stage; StartStage(Unit*);`)
선택되는 유닛이 같아도 Stage에 추가할 때, 유닛의 순서가 달라진다면 결과도 달라지게 된다.

유닛의 이동 순서가 연쇄로 일어나는 것은 <span style="color:rgb(255, 192, 0)">객체간의 종속성이 강하다</span>는 것을 뜻한다.

만약, 객체의 순서를 하나라도 잘못 지정해주면 원치않는 결과가 나와버린다.
객체가 늘어날 수록 실수할 가능성은 더욱 높아질 것이고, 오류의 원인을 찾으려면 서로 연관된 코드를 다 확인해야 하는 불상사가 생길 수 있다.

이를 해결하기 위해서는 객체간의 종속성을 끊어야한다.
위의 코드에서 조건 자체가 유닛의 이동 순서와 연관이 있는거 같은데 순서를 지정해주는걸 없애서 종속성을 끊으면 결과가 옳게 나오나? 라고 의심을 품을 수 있다.
하지만 가능하다. 다음 해결 방법을 보자.

### 해결 방법
이중 버퍼 패턴의 핵심인 이중 버퍼가 활약할 시간이다.
이번에는 **Stage Class의 update()**에서 세가지 과정을 거칠 것이다.

##### 1단계 : 상태 결정
- 핵심 부분으로 이번턴에 움직일 유닛들을 백 버퍼에 미리 등록해준다.
```cpp
for (int index : movedUnitIndices) {
	if (index >= 0 && index < backBuffer_.size()) {
		backBuffer_[index].isMoved = true; 
	} 
}
```

##### 2단계 : 상태 반영
- 모든 유닛의 상태를 계산한다. (조건에 따라 이동 여부 결정)
```cpp
for (size_t i = 0; i < units_.size(); ++i) {
	units_[i]->update(backBuffer_); 
}
```
- 이는 backBuffer_를 unitA클래스에 넘겨줌으로써 거기에서 backBuffer를 for문으로 순회하면서 조건을 만족하는지 확인하는 방법이다.
>**발생할 수 있는 문제점**
>각 유닛이 영향받는 특정 유닛이 하나뿐이라 하면 <span style="color:rgb(255, 192, 0)">for문을 도는게 불필요한 순회</span>가 될 수 있다. 그럼 유닛이 많을 수록 <span style="color:rgb(255, 192, 0)">시간복잡도가 늘어나 성능이 떨어지는 문제</span>를 야기할 수 있다.
>
>**해결 방법**
> ```cpp hl:3
> class Stage {  
> 	// <유닛, isMoved 값>
> 	std::unordered_map<Unit*, bool> backBuffer_;
>
>	bool getRelatedUnitMoved(Unit* relatedUnit){
>		return backBuffer_[relatedUnit].isMoved;
>	}
>};
>
>class UnitA{
>	virtual void update() override { 
> 		 // 관련 유닛의 상태만 확인 
> 		 if (stage.getRelatedUnitMoved(relatedUnit_)) {
> 			  // 위치 이동
> 		} 
> 	}
> };
>```
><span style="color:rgb(255, 192, 0)">backBuffer를 map으로 구현</span>하여, 원하는 유닛의 `isMoved`값만 가져올 수 있도록 해준다.


##### 3단계 : 버퍼 교체
```cpp
frontBuffer_.swap(backBuffer_);
```
- swap을 통해 currentLocation을 nextLocation으로 업데이트 해준다.

이렇게 하면 처음 시작 유닛을 지정해 주지 않아도 된다.
이는 시작 유닛을 지정해 주는 대신, 이번 스테이지에 참가할 유닛들을 추가하는 방식으로 바꾼것이다.

여기서 헷갈리는 부분이 있을 수 있는데, BackBuffer에 등록하는 유닛들이 결과적으로 움직이게 되는것이 아니다.
