#### 핵심 개념
이중 버퍼 패턴은 현재 버퍼(FrontBuffer)와 다음 버퍼(BackBuffer)를 가진다.
- Front Buffer : 현재 화면에 표시되고 있는 버퍼, 비디오 드라이버는 이 버퍼에서만 데이터를 읽고 화면에 출력한다. (읽기용)
- Back Buffer : 다음 프레임을 준비하는 버퍼, 코드는 이 버퍼에만 값을 쓴다. (쓰기용)

---

#### 문제 상황
게임이 실행되는 동안 비디오 디스플레이가 프레임 버퍼를 반복해서 읽는다.
이때 코드가 프레임 버퍼에 값을 쓰는 도중, 비디오 드라이버가 프레임 버퍼를 읽어서 화면에 출력해버리면 의도와 다르게 일부만 출력되는 문제(*테어링*)가 발생할 수 있다.
>**테어링**
>화면이 찢어진 것처럼 보이는 현상

<br>

#### 해결 방법 (목적)
이를 방지하기 위해서 다음과 같이 **이중 버퍼 패턴**을 사용할 수 있다. 

1. 백 버퍼에 게임 코드가 한 프레임 값을 다 작성한다.
2. 백 버퍼와 프론트 버퍼를 교체한다.
3. 드라이버가 프론트 버퍼를 읽고 화면에 출력한다. 

이처럼 여러 순차 작업의 결과를 한 프레임에 보여줄 때 이중 버퍼를 사용하면 테어링 문제를 방지할 수 있다.

이를 통해 이중 버퍼 패턴은 쓰는 작업이 완료된 후 한번에 읽기 작업을 진행해 일관성을 보장하는 것이 핵심 목적임을 알 수 있다.

---

### 이중 버퍼 패턴 적합한 상황
> **순차적으로 변경해야 하는 상태**

여러 순차적 작업의 결과가 일관된 상태로 완료되어야 할 때(작업이 끝까지 실행되지 않은 상태에서 끝나지 않도록) 이중 버퍼 패턴을 사용할 수 있다.

이중 버퍼를 사용하여, 순차적 작업이 완료되어야 외부에서 접근 가능한 상태가 되도록 하는 것이다.

<br>

>**외부에서 작업 중인 상태에 접근이 불가능 하도록 해야 할 때**

작업 중인 백버퍼에 비디오 드라이버와 같은 외부 시스템이 접근하는 것을 막아 데이터의 일관성을 보장한다. (테어링 현상 방지)

---

### 그래픽스 외 사용법
이번에는 상태를 변경하는 코드가 다른 변경하려는 상태를 읽는 경우에 대해 알아보자.

유닛A, 유닛B, 유닛C가 있고 각각은 특정 유닛의 이동 유무에 따라 움직인다.
- C가 이동한 뒤 A가 이동
- A가 이동한 뒤 B가 이동
- B가 이동한 뒤 A가 이동

#### Unit Class
```cpp title:Unit
class Unit{ 
public:
	Unit() : currentLocation_(0,0,0){}
	virtual ~Unit();
	virtual void update() = 0;
	
	void swap(){
		currentLocation_ = nextLocation_;
		bIsMoved = false;
	}
	
	bool wasMovedThisTurn(){
		return bIsMoved;
	}

	void setNextLocation(conast FVector& newLocation){
		nextLocation_ = newLocation;
		bIsMoved = true;
	}
	
private:
	FVector currentLocation;
	FVector nextLocation;
	bool bIsMoved = false;
};
```
유닛이 공통적으로 가지는 것들을 모아 Unit 클래스에 작성하였다.
- **swap**
	- `currentLocation_`를 `nextLocation_`값으로 업데이트 해준다.
- **wasMovedThisTurn**
	- 움직였는지를 반환한다.
- **setNextLocation**
	- `nextLocation_`를 새 위치로 업데이트 해준다.

#### Units 
```cpp title:UnitA
class UnitA : public Unit{
public:  
	void setRelatedUnit(Unit* relatedUnit){
		relatedUnit_ = relatedUnit;
	}
	
	virtual void update() override {
		if(relatedUnit_ && relatedUnit_()->wasMovedThisTurn()){
			setNextLocation(/*NewLocation*/);
		}
		else{
			setNextLocation(currentLocation);
		}
	}

private:
	Unit* relatedUnit_;
}
```
- Unit클래스를 상속받는다.
- **setRelatedUnit**
	- 이동 조건에는 특정 유닛의 이동 여부가 들어가는데 그 특정 유닛을 설정하는 함수이다.
- **update**
	- 조건을 설정하고, 조건이 만족되면 위치를 새로운 위치로 업데이트한다.
	- 조건을 만족하지 않으면 현재 위치를 그대로 넘겨준다.

#### Stage Class
```cpp title:Stage
class Stage{ 
public:
	void add(Unit* unit, int index){
		units_[index] = unit
	}
	
	void update(){
		for(int i = 0; i < NUM_UNITS; i++){
			units_[i]->update();
		}
		for(int i = 0; i < NUM_UNITS; i++){
			units_[i]->swap();
		}
	}

	void StartStage(Unit* unit){
		unit->setNextLocation();
		update();
	}
	
private:
	static const int NUM_UNITS = 3;
	Unit* units_[NUM_UNITS];
}
```
유닛이 움직이는 무대를 나타내는 클래스이다.
- **add**
	- 유닛을 등록한다.
- **update**
	- 이중 버퍼 패턴의 핵심 부분이다.
	- **units_[i]->update()**
		- 각 유닛의 이동 조건 만족 여부에 따라 이동 여부를 정한다. 
		- 조건이 만족되면 `nextLocation`에는 새로운 위치들이 할당된다.
		- `bIsMoved` 값이 true이다.
**swap**
	- `currentLocation_`에 `nextLocation_`값을 할당해준다.
	- 외부시스템은 `currentLocation_`값만 읽는다. 
	- update와 swap을 분리해놓고 순차적으로 실행시킴으로써 외부 시스템은 값 변경이 전부 실행된 값을 읽을 수 있게 된다.

#### Main 실행 예시
```cpp
int main(){
	State stage;
	
	Unit* unitA = new Unit();
	Unit* unitB = new Unit();
	Unit* unitC = new Unit();

	unitA->setRelatedUnit(C);
	unitB->setRelatedUnit(A);
	unitC->setRelatedUnit(B);

	stage.add(unitA, 0);
	stage.add(unitB, 1);
	stage.add(unitC, 2);

	stage.StartStage(unitC);
};
```
`unitC->setNextLocation()`을 먼저 해주는 이유는 C를 먼저 해주어야 A가 이동하는 조건이 달성되기 때문이다.

---

인벤토리의 일관성 보장
```cpp
struct Item{
	int id;
	string name;
};

using InventofyBuffer = vector<Item>;

class InventoryManager{
public:
	void addItem(const Item& item){
		// 백 버퍼에 추가
		pendingBuffer_.push_back(item);
		//변경 발생 알림
		hasChange_ = true;
	}

	void updateAndSwap(){
		if(hasChange_){
			activeBuffer_.swap(pendingBuffer_);
			hasChange_ = false;
			pendingBuffer_.clear();
		}
	}

	const InventoryBuffer& getInventory() const{
		return activeBuffer_;
	}

private:
	InventoryBuffer activeBuffer_;
	InventoryBuffer pendingBuffer_;
	bool hasChange_ false;
}
```