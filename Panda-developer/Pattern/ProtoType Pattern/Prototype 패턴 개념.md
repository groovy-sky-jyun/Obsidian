### Prototype이란?
게임에서 동일한 객체(독립적인)를 대량으로 생성해야 할 때, 매번 new 키워드를 사용하여 객체를 초기화하는 것은 비효율적이다.

프로토타입은 이러한 문제를 해결하기 위해, <span style="color:rgb(255, 207, 61)">객체의 원형(프로토타입)</span>을 미리 만들어 두고, 필요할때마다 <span style="color:rgb(255, 207, 61)">원형을 복제</span>하여 새로운 객체를 생성하는 방식이다.

---

### 목적
##### 1. 객체 생성 비용 절감
- 복잡한 초기화 과정을 반복하는 대신 <span style="color:rgb(255, 207, 61)">메모리 복사</span>를 통해 단순 연산으로 객체를 빠르게 만들어 낼 수 있다.

> **메모리 복사**

**깊은 복사**를 뜻한다. 새로운 메모리 블록을 할당하고, 원본 객체의 모든 데이터를 새로운 메모리에 복사하여 독립적인 객체를 생성 및 초기화한다.

##### 2. 클래스 의존성 제거(상속)
- 특정 클래스에 의존하지 않고, Clone() 메소드 호출만으로 객체를 생성할 수 있다.
- 새로운 클래스를 추가하거나 기존 클래스를 변경할 때 <span style="color:rgb(255, 207, 61)">유연성</span>을 높여준다.

>**클래스 의존성 제거**

클래스에 의존하는 코드는 객체를 생성할 때마다 특정 클래스 이름을 직접 지정해야 한다. 이러면 클래스 의존성이 높아지고 유연성이 떨어지게 된다. (몬스터를 생성하려면 클래스 이름을 무조건 알아야 하기 때문)
`Goblin* goblin1 = new Goblin();`

프로토타입 패턴을 사용하면 클라이언트가 몬스터 상세 클래스 이름을 알지 못하더라도 데이터 키값만으로 객체를 생성할 수 있다. (키값만 알면되고 어떤 클래스가 필요한지는 몰라도 된다.)
`unique_ptr<IPrototype> monster1 = manager.GetClonedMonster("goblin");`

---

### 패턴 미/적용 차이
```cpp title:Prototype적용x hl:5
int main() {   
	// DB에서 고블린 데이터 불러오기 
	MonsterData goblinData = {"고블린", 100, 10, {"찌르기", "은신"}}; 
	// 몬스터 생성 시 데이터 전달 필요
	Monster* goblin1 = new Monster(goblinData.name, goblinData.health, goblinData.attack, goblinData.skills); 
	
	delete goblin1;
	
	return 0; 
}
```

```cpp title:Prototype적용o hl:5
int main() {   
	// 1. 원본 객체(프로토타입)를 단 한 번만 생성 
	std::unique_ptr<Monster> goblinPrototype = std::make_unique<Monster>("고블린", 100, 10, std::vector<std::string>{"찌르기", "은신"}); 
	// 2. 이후에는 Clone() 메소드 호출만으로 객체 생성
	std::unique_ptr<IPrototype> goblin1 = goblinPrototype->Clone();
	
	return 0;
}
```

두 코드를 비교해 보면 <span style="color:rgb(255, 207, 61)">새로운 객체를 초기화 하는 방법이 다른것을 알 수 있다.</span>

Prototype 패턴을 적용하기 전에는 모든 데이터를 매개변수를 통해 생성자에 넘겨주어야 한다. 

대신, 패턴을 사용하면 존재하는 <span style="color:rgb(255, 207, 61)">원본 객체의 데이터를 복사해서 새로운 객체를 초기화</span>한다. 

즉, 긴 매개변수를 이용하는 대신 <span style="color:rgb(255, 207, 61)">복사 생성자</span>를 호출함으로써 간단하게 객체를 생성 및 초기화 할 수 있는 것이다.

---

### 사용 예시
##### 다양한 몬스터 생성
기본 고블린 프로토타입을 만들어두고, 이를 복제하여 능력치만 조금씩 다른 '강화된 고블린', '마법사 고블린' 등을 쉽게 만들 수 있다.

##### 아이템 드롭 시스템
몬스터 처치 시 무작위 아이템을 드롭할 때, 아이템 프로토타입을 복제하여(아이템 정보만 다르게) 인벤토리에 추가하는 방식으로 구현할 수 있다.
- 아이템 프로토타입은 아이템들이 공통으로 가지는 <span style="color:rgb(255, 207, 61)">기본 정보를 담고 있는 틀</span>과 같다.(고유ID, 이름, 아이콘 이미지 경로, 공격력/방어력, 설명 텍스트, 등급 등)
- 아이템 종류별 세부 데이터는 데이터 베이스가 가지고 있다.
- 드롭 테이블에서 아이템 ID를 받고, 데이터베이스에서 해당 ID와 일치하는 데이터를 가져와 이를 바탕으로 아이템을 복제한다.

##### 탄막 패턴
수많은 총알 객체를 생성해야 할 때, 총알 프로토타입을 복제하여 발사체의 속도나 방향만 바꾸는 방식으로 효율적으로 생성할 수 있다.

---

### FlyWeight 패턴과의 차이점
둘은 대량의 동일 객체를 만드는데 사용된다는 점이 같지만 패턴의 사용목적은 분명하게 다르다.

**FlyWeight**는 여러 동일 객체가 있을 때 <span style="color:rgb(255, 207, 61)">데이터 관리</span>를 어떻게 할 것인가에 관해 초점이 맞춰져 있다.

**Prototype**은 여러 동일 <span style="color:rgb(255, 207, 61)">객체를 어떻게 생성</span>할 것인가에 대해 초점이 맞춰있다.

##### <mark style="background: #ADCCFFA6;">FlyWeight</mark>
- 목적
	- 메모리 사용량 절감
	- 데이터 재사용
- 구조
	- **<span style="color:rgb(255, 207, 61)">공통 데이터</span>**와 **<span style="color:rgb(255, 207, 61)">개별 데이터</span>**로 분리한 두개의 객체
	- 객체마다 데이터를 복사하는 대신 하나의 공유 데이터로 관리
- 기존 원형 객체를 재사용

##### <mark style="background: #ADCCFFA6;">Prototype</mark>
- 목적
	- 객체 생성 비용 절감
	- 원형 복제
- 구조
	- 모든 데이터를 가진 원형 객체
	- 객체 생성마다 초기화 과정을 반복하지 않고, 이미 만들어진 객체를 복제하여 빠르게 생성
- 기존 **<span style="color:rgb(255, 207, 61)">원형 객체</span>**를 통해 깊은 복사로 **<span style="color:rgb(255, 207, 61)">복제본 객체</span>** 생성 및 초기화

