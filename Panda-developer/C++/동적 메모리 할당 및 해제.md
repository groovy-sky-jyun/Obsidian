### #Heap
힙 메모리가 부족하면 new 생성자는 `std::bad_alloc` Exception을 Throw 한다.
그러므로 new 생성자를 쓸 땐 리턴값이 Null 인지 확인하는 것이 좋다.
```cpp
int *p = new int; //new는 포인터 변수 반환
if(!p) { return; }

*p = 5;
int n = *p;

delete p;
```

---
### #배열
```cpp
int *p = new int[5];
if(!p) { return; }

delete[] p;
```
포인터 p는 delete 된 후에는 메모리가 해제되었기 때문에 이후에 배열 포인터로 재사용할 수 없다. 다시 사용하려면 새로운 메모리를 다시 할당해 주어야 한다.

### #다차원배열
```cpp
//이중 포인터 10개 행 포인터 할당
int **pArray = new int*[10]; 
for(int i=0; i<10; i++){
	pArray[i] = new int[20];
}

// 1. 10개 행 포인터 해제
for(int i=0; i<10; ++i){
	delete[] pArray[i];
}
// 2. 이중포인터 해제
delete[] pArray;
```
다차원 배열을 해제하기 위해서는 1. 각 행 포인터를 먼저 해제해준 뒤, 2. 이중 포인터를 해제해주어야 한다.

---
### #객체
#### 객체 동적 생성
new를 사용한 객체 동적 생성은 괄호의 유무가 상관없다.
new를 사용하므로써 생성자를 호출한다는 의도가 명확하기 때문이다.
```cpp
Circle *p = new Circle; // 생성자 호출
Circle *p = new Circle(); // 생성자 호출
```

>__생성자 호출 시 주의__
>매개변수 없는 생성자를 호출할 때 생성자도 함수라고 괄호를 붙여선 안된다.
>괄호를 붙이면 생성자가 아닌 해당 클래스를 반환하는 메소드로 인식하기 때문이다.
>```cpp
>Circle waffle; // 생성자 호출
>Circle waffle(); // return 값이 Circle인 waffle함수 호출
>```

<br>

#### 객체 동적 해제
객체가 여러개 생성될 때 서로 독립된 메모리 블록을 가지기 때문에 delete는 생성 순서와 상관없이 진행이 가능하다.

<br>

### #객체배열
#### 객체 배열 동적 생성 (매개 변수)
객체 배열을 동적으로 생성할 땐 매개변수가 있는 생성자를 호출할 수 없다.

매개변수가 있는 생성자를 호출하고자 한다면 원소 객체로 초기화 해주어야 한다.
이때, 원소 객체로 초기화 해주지 않은 객체들은 기본 생성자로 초기화 된다.
그렇기에 이 경우에는 무조건 기본 생성자가 정의되어 있어야 한다. 그렇지 않으면 오류가 발생한다.

```cpp
#include <iostream>
using namespace std;

class Circle {
    int r;
public:
    Circle(int r = 1) : r(r) {
        cout << "반지름: " << r << '\n';
    }
};

int main(){
	Circle *p = new Circle[5]();
	Circle *p = new Circle[5](30); //매개변수 한개를 가진 생성자 호출 시 오류
	Circle *p = new Circle[5]{Circle(3), Circle(), Circle(30)}; //남은 2개는 기본 생성자로 초기화
}

//출력 결과 : 3 1 30 1 1
```
>__객체 생성 메모리 영역__
>지역 객체는 Stack에 생성된다.
>그래서 가장 나중에 생성된 객체가 가장 먼저 소멸된다.
>
> 반면, new 키워드를 사용하여 생성할 경우 Heap에 생성되어 delete 키워드를 사용하여 순서와 상관없이 소멸시킬 수 있다.
> 
> 전역 변수와 static 변수는 Data Segment에 존재한다.

<br>

#### 객체 배열 동적 해제
객체 배열을 delete하면 Index 높은 순부터 해제된다. (배열도 동일)

배열은 독립된 메모리 블록이 아니고, 하나의 연속된 메모리 블록이기 때문에 RAII 원칙에 따라 안전한 리소스 해제를 위해 생성의 역순으로 객체를 소멸한다.
>__RAII 원칙__
>디자인 패턴 중 하나로 리소스 수명을 객체 수명에 바인딩하여 멤리 누수를 방지하는 목적을 지니고 있다.

---

### #메모리 누수
동적으로 메모리를 할당하고 해제하지 않은 상태에서 접근할 수도 없는 상태를 말한다.

이런 메모리가 누적되면 메모리 부족으로 성능이 저하될 수 있다.
```cpp
char n = 'a';
char *p = new char[1024];
p = &n; //메모리 누수 발생
```
위의 코드를 보면 char 1024개 배열을 만들고 p에 그 시작 주소를 가리키도록 설정해주었다. 
그런 뒤 p가 n의 주소를 가리키도록 변경해주면 char 1024개의 배열은 해제될 수도 없고, 사용되지도 않은 채 메모리만 차지하게 되는 것이다.