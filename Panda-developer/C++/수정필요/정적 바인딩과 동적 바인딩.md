### 정적 바인딩
정적 바인딩은 컴파일 시간에 어떤 함수를 호출할지 미리 확정한다. 하여 컴파일 이후에는 호출하는 함수가 변하지 않는다.

호출되는 함수의 <span style="color:rgb(255, 207, 61)">포인터/참조 타입</span>만 보고 함수를 결정하며, 객체의 실제 타입은 무시한다. <span style="color:rgb(125, 125, 125)">(포인터/참조가 아닌 실제 객체를 통해 함수를 호출할 경우, 객체 자신의 함수가 호출된다.)</span>

컴파일 시간에 포인터/참조 타입만 보고 호출할 함수 주소가 결정되니까 실행 시간에 객체의 실제 타입이 무엇이든 상관없어진다. 그래서 이름 숨김 현상이 발생하는 것이다.

아래의 코드를 보면 `Base*`는 UpCasting 되었지만 `ptr->show();`는 `Base*`의 `show()`가 호출되는것을 볼 수 있다. 이는 객체 타입보다 포인터 타입을 우선시 하기 때문이다.

```cpp title:정적바인딩 hl:13
class Base{ 
public:
	void show(){}
};

class Derived : public Base{
public:
	void show(){}
};

int main(){
	Base* ptr = new Derived();
	ptr->show(); //Base의 show호출
}
```

---
### 동적 바인딩
동적 바인딩은 실행 중 가상 함수가 호출되면, 객체 내 오버라이딩된 가상 함수를 동적으로 찾아 호출한다.

즉, 파생 클래스의 객체에 대해, 기본 클래스 포인터로 가상 함수가 호출될 때 일어난다.

이는 파생 클래스에서 재정의한 가상 함수의 호출을 보장받을 수 있다는 것을 뜻한다.
>**동적 바인딩이 발생하는 상황**
>- 기본 클래스의 멤버 함수에서 가상 함수 호출
>- 파생 클래스의 멤버 함수에서 가상 함수 호출
>- 외부 함수에서 기본 클래스의 포인터로 가상 함수 호출
>- 다른 클래스에서 가상 함수 호출

<span style="color:rgb(255, 207, 61)">실행 시간 바인딩</span>이라고도 부르며 정적 바인딩과 달리 포인터/참조 타입에 따라 실행될 함수가 결정되는것이 아닌 <span style="color:rgb(255, 207, 61)">객체 타입</span>에 따라 결정된다.
```cpp title:기본클래스멤버함수에서가상함수호출 hl:4,14,21
class Base { 
public: 
	void printStatus() {
		show(); // 가상 함수 호출
	}

	virtual void show() {
		cout << "base" << endl;
	}
}; 

class Derived : public Base {
public:
	virtual void show() override {
		cout << "derived" << endl;
	}
};

int main() {
	Base* pBase = new Derived();
	pBase->printStatus(); //출력: derived
}
```

```cpp title:외부함수에서가상함수호출 hl:3,10,16,17
class Base {  
public:
	virtual void show() {
		cout << "Base" << endl;
	} 
};

class Derived : public Base {
public:
	virtual void show() override {
		cout << "Derived" << endl;
	}
};

int main() {
	Base* ptr = new Derived();
	ptr->show(); //출력: Derived
}
```

<span style="color:rgb(255, 82, 82)">실행 시간 다형성</span> 