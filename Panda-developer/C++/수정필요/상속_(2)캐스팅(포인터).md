### 업 캐스팅
하나의 기본 클래스 포인터/참조로 여러 파생 클래스 객체를 가리키는 말한다. (다형성)

#### 예시
아래의 코드는 간단한 설명을 위해 상세코드는 생략했다.

**16-17line**
매개변수로 `Item`클래스의 참조 타입을 받고 있다. 
업캐스팅을 통해 여러 파생 클래스 객체를 하나의 포인터로 받을 수 있도록 하였다.

**26-27line**
업캐스팅이 일어나는 구간이다.
업캐스팅 덕에 어떠한 파생 클래스라도 인자로 넘겨줄 수 있다.
```cpp title:업캐스팅예시 hl:16-17,26-27
class Item {  
	//...
};

class Potion : public Item {
	//...
};

class Sword : public Item {
	//...
};

class Inventory {
	vector<Item*> items;
public:
	void AddItem(const Item& newItem) {
		items.push_back(newItem);
	}
};

int main() {
	Potion potion;
	Sword sword;
	
	Inventory* inventory = new Inventory;
	inventory->AddItem(potion);
	inventory->AddItem(sword);

	delete inventory;
	return 0;
}
```

<span style="color:rgb(255, 82, 82)">(구조)</span>

#### 업 캐스팅 포인터의 접근 권한
- 기본 클래스의 public 멤버만 접근할 수 있다.
	- protected 멤버는 클래스 외부에서 접근 불가능
- <span style="color:rgb(255, 207, 61)">파생 클래스의 public 멤버에 접근할 수 없다.
</span>
```cpp title:Up-casting hl:19
class Parent {     
public: 
	void getParentAge();
	//... 
};

class Child : public Parent {
public:
	void getChildAge();
	//...
};

int main() {
	Child child;
	Child* pChild = &child;

	Parent* pParent = pChild; // 업 캐스팅
	pParent->getParentAge(); // 정상
	pParent->getChildAge(); // 오류
}
```

#### 사용 예시
<span style="color:rgb(255, 207, 61)">인터페이스를 통해 여러 객체를 동일하게 다룰 때</span> 사용된다.

예로 Inventory 클래스에서 다양한 무기, 방어구, 포션 등을 Item 이라는 기본 클래스 포인터 배열에 담고 관리하는 상황에 사용할 수 있다.
```cpp title:Up-castingExample
vector<Item*> items; 
items.push_back(new Weapon());
items.push_back(new DefensiveGear());
items.push_back(new Potion());
```

##### 1. 정적 바인딩에서의 업캐스팅
##### 2. 동적 바인딩에서의 업캐스팅
---
### 다운 캐스팅
<span style="color:rgb(255, 207, 61)">기본 클래스 포인터</span>를 <span style="color:rgb(255, 207, 61)">파생 클래스 포인터 타입으로 변환</span>하는 것을 다운 캐스팅이라 한다.

다운 캐스팅을 통해 파생 클래스 포인터 타입으로 변환되면 <span style="color:rgb(255, 207, 61)">파생 클래스의 public 멤버에도 접근이 가능</span>하다.

기본 클래스는 하나이지만 파생 클래스는 여러개가 될 수 있으므로(자식 클래스는 여러개 가질 수 있다.) 다운 캐스팅을 할 경우 반드시 <span style="color:rgb(255, 207, 61)">강제 타입 변환</span>을 해주어야 한다.

<span style="color:rgb(255, 82, 82)">(구조)</span>

#### 주의 사항
다운 캐스팅은 <span style="color:rgb(255, 207, 61)">업 캐스팅된 객체를 다시 원래 객체로 되돌릴 때</span>만 사용해야 한다. 

>**상황**
그냥 기본 클래스 객체를 파생 클래스 객체로 다운 캐스팅 하는 경우

>**문제**
다운 캐스팅된 포인터로 <span style="color:rgb(255, 207, 61)">메모리 공간에 없는 멤버에 접근</span>하게 되면 <span style="color:rgb(255, 207, 61)">쓰레기값</span>을 가져오거나 충돌로 프로그램이 <span style="color:rgb(255, 207, 61)">비정상 종료</span>될 수 있다.

> **이유**
>  다운 캐스팅을 한다고 해서 자동으로 메모리 공간이 파생 클래스 크기만큼 확장되는 것이 아니기 때문이다. 메모리 공간은 기본 클래스만큼 가지고 있는데 파생 클래스 멤버에 접근하려고 하니 문제가 발생하는 것이다.
```cpp title:Down-castingError hl:20
class Parent {   
public:
	void getParentAge();
	//...
};

class Child : public Parent {
public:
	void getChildAge();
	//...
};

int main() {
	Parent parent;
	Parent* pParent = &parent;

	// 다운 캐스팅
	Child* pChild = (Child*)pParent; // 강제 타입 변환
	pChild->getParentAge(); //정상
	pChild->getChildAge(); // 쓰레기값
}
```

>**해결 방법**
업 캐스팅된 객체를 다시 원래 객체로 되돌릴 때만 다운 캐스팅을 사용한다.
```cpp hl:9 title:Up/DownCasting
int main() { 
	Child child;
	Child* pChild = &child;
	 
	Parent* pParent = pChild; // 업 캐스팅

	pChild = (Child*)pParent; // 다운 캐스팅
	pChild->getParentAge(); //정상
	pChild->getChildAge(); // 정상
}
```

#### 사용 예시
인터페이스에서 특정 객체의 고유한 기능에 접근할 때 사용된다.

*<span style="color:rgb(125, 125, 125)">(Up-castingExample)</span>* 코드의 Item 배열에서 특정 아이템이 Weapon인지 확인하고 Weapon에만 존재하는 함수를 호출할 때 사용할 수 있다.
```cpp
void processWeapon(Item* item){
	Weapon* weapon = (Weapon*)item; // 다운 캐스팅
	if(weapon){
		//weapon에만 존재하는 함수 호출
	}
}
```

---
### 캐스팅을 포인터로 하는 이유
포인터로 업/다운 캐스팅을 할 경우 포인터의 타입만 변경될 뿐, 실제 객체의 메모리 크기나 구조에는 영향을 주지 않는다.

업 캐스팅을 한다고 해서 메모리 크기가 줄어들지 않고, 다운 캐스팅을 한다고 해서 메모리가 늘어나지 않는것이다.

#### 일반 객체로 캐스팅 할 경우 발생하는 문제 
객체는 자신의 고유한 메모리 공간을 할당받는다. 

메모리 공간 자체를 그대로 업/다운 캐스팅 해버리면 메모리 공간이 늘어났다가 줄어들었다가 하게된다. 

메모리 공간이 늘어나는 경우, 불필요한 메모리 공간을 가지게 되거나 객체 자체가 다른 객체가 되어 <span style="color:rgb(255, 207, 61)">다형성을 상실</span>하게 된다. (메모리 공간이 다른 객체와 동일하게 변하였으므로)

메모리 공간이 줄어드는 경우, 필요한 메모리가 slicing 되는 문제 (<span style="color:rgb(255, 207, 61)">데이터 손실</span>)가 발생할 수 있다.

그래서 일반 객체 타입 변환은 허용되지 않는다.