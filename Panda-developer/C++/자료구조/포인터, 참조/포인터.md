### *포인터

포인터는 메모리 주소를 저장하는 하나의 변수이다.

가리키는 주소를 다른 주소로 변경할 수 있다. 즉, 다른 객체로 포인터를 변경할 수 있다.

초기화값으로 nullptr을 가질 수 있기에 유효성 체크가 필요하다.

저장한 주소를 이용해 객체나 변수에 접근한다.

```cpp
int a = 10;
int b = 20;
int* ptr = &a; // ptr은 a의 주소를 저장

*ptr = 30;  // ptr이 가리키는 값(즉, a)을 30으로 변경

std::cout << "a: " << a << ", b: " << b << std::endl; // a: 30, b: 20

ptr = &b;  // ptr이 이제 b의 주소를 가리키게 됨
*ptr = 40;  // ptr이 가리키는 값(즉, b)을 40으로 변경
std::cout << "a: " << a << ", b: " << b << std::endl; // a: 30, b: 40
```

### 포인터 예시
```cpp
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int arr[2][3] = { 1,2,3,4,5,6 };
    int (*p)[3] = NULL;
    p = arr;

    printf("%d, ", *(p[0] + 1) + *(p[1] + 2));
    printf("%d", *(*(p + 1) + 0) + *(*(p + 1) + 1));

}
```

__1) 포인터 배열 P[3]__
1) p는 크기가 3인 포인터 배열이다.
2) p[0]은 arr[0]의 주소, p[1]은 arr[1]의 주소, p[2]는 arr[2]의 주소를 가리킨다.
3) 이때, arr[2]는 존재하지 않음으로 p[2]는 잘못된 접근이다.
<br>

__2) `*(P[0] + 1)`__
1) 배열은 첫번째 원소의 주소값을 가리켜 포인터처럼 동작한다.
2) arr[0]은 {1,2,3} 에서 1의 주소값을 가리키고 있다.
3) p[0] 또한 arr[0] 의 첫번째 원소의 주소값을 가리키고 있다. (1의 주소)
4) 하여 p[0] + 1을 하면 두번째 원소인 2의 주소를 가리키게 된다.
5) 이를 역참조 했으므로 최종 값은 2가 된다.
<br>

__3) `*(P[1] + 2)`__
1) p[1]은 arr[1]을 가리키고 있다.
2) arr[1]은 {4,5,6} 에서 4의 주소값을 가리키고 있다.
3) 그러므로, p[1] 또한 arr[1] 의 첫번째 원소의 주소값을 가리키고 있다. (4의 주소)
4) 하여 p[1] + 2을 하면 세번째 원소인 6의 주소를 가리키게 된다.
5) 이를 역참조 했으므로 최종 값은 6이 된다.
<br>

__4) `*(P[1] + 2)`__
1) p[1]은 arr[1]을 가리키고 있다.
2) arr[1]은 {4,5,6} 에서 4의 주소값을 가리키고 있다.
3) 그러므로, p[1] 또한 arr[1] 의 첫번째 원소의 주소값을 가리키고 있다. (4의 주소)
4) 하여 p[1] + 2을 하면 세번째 원소인 6의 주소를 가리키게 된다.
5) 이를 역참조 했으므로 최종 값은 6이 된다.
<br>

__5) `*(*(p + 1) + 0)`__
1) p는 arr의 첫번째 원소값 주소를 가리킨다. 즉 arr[0]의 주소를 가리킨다.
2) p + 1은 arr의 두번째 원소값 주소를 가리킨다. 즉, arr[1]의 주소를 가리킨다.
3) `*(p + 1)` 처럼 이를 역참조하면 arr[1]이 가리키는 값 즉, arr[1]={4,5,6} 의 첫번째 원소값을 가리키게 된다. -> 4의 주소를 가리킴
4) `*(*(p + 1))`을 통해 이를 한번 더 역참조하면 4의 값을 얻을 수 있다.
<br>

__6) `*(*(p + 1) + 1)`__
1) p + 1은 arr의 두번째 원소값 주소를 가리킨다. 즉, arr[1]의 주소를 가리킨다.
2) `*(p + 1) + 1` 처럼 이를 역참조하면 arr[1]이 가리키는 값 즉, arr[1]={4,5,6} 의 첫번째 원소값을 가리키게 된다. + 1을 해줬으므로 5의 주소를 가리키게 된다.
3) `*(*(p + 1) + 1)`을 통해 이를 한번 더 역참조하면 5의 값을 얻을 수 있다.
<br>

>#### p 와 p[0])의 차이
>p는 arr배열의 첫번째 인덱스 주소를 가진다. -> arr[0]
>p[0]은 arr배열의 첫번째 원소 주소값을 가리킨다. -> arr[0] = {1,2,3} 에서 1