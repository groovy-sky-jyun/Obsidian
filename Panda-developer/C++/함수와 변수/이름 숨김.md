### Name Hiding (feat.상속)
파생 클래스에서 기본 클래스의 특정 함수를 덮어써서 파생 클래스 고유 동작을 정의하기 위해 사용된다.

상속관계에서 사용될 수 있으며, 기본 클래스의 특정 함수를 파생클래스에서 같은 이름으로 재정의하는 것을 뜻한다. 이때, 기본 클래스의 함수는 숨겨지게 된다.

재정의하는 함수는 반환타입, 이름, 매개타입이 전부 같아야 한다. <span style="color:rgb(125, 125, 125)">(매개변수의 변수명은 달라도 괜찮다.)</span>

<span style="color:rgb(255, 82, 82)">(객체 구조 사진)</span>

```cpp title:이름숨김예시 hl:2,7,8
class Person{   
	void ageBoundary(){
		cout << "20세 이상 성인" << endl;
	}
}; 

class Child : public Person{
	void ageBoundary(){
		cout << "19세 이하 청소년" << endl;
	}
};

int main(){
	Child child;
	child.ageBoundary(); //출력: 19세 이하 청소년
}
```

---
### 정적 바인딩
정적 바인딩은 컴파일 시간에 어떤 함수를 호출할지 미리 확정한다. 하여 컴파일 이후에는 호출하는 함수가 변하지 않는다.

호출되는 함수의 <span style="color:rgb(255, 207, 61)">포인터/참조 타입</span>만 보고 함수를 결정하며, 객체의 실제 타입은 무시한다. <span style="color:rgb(125, 125, 125)">(포인터/참조가 아닌 실제 객체를 통해 함수를 호출할 경우, 객체 자신의 함수가 호출된다.)</span>

컴파일 시간에 포인터/참조 타입만 보고 호출할 함수 주소가 결정되니까 실행 시간에 객체의 실제 타입이 무엇이든 상관없어진다. 그래서 이름 숨김 현상이 발생하는 것이다.

아래의 코드를 보면 `Base*`는 UpCasting 되었지만 `ptr->show();`는 `Base*`의 `show()`가 호출되는것을 볼 수 있다. 이는 객체 타입보다 포인터 타입을 우선시 하기 때문이다.

```cpp title:정적바인딩 hl:13
class Base{ 
public:
	void show(){}
};

class Derived : public Base{
public:
	void show(){}
};

int main(){
	Base* ptr = new Derived();
	ptr->show(); //Base의 show호출
}
```

---
### 범위 지정 연산자
이름 숨김은 범위 지정 연산자`::`를 통해 **정적 바인딩을 강제**할 수 있다.

이 방법은 파생 클래스에서 기본 클래스의 이름 숨김 함수를 호출할 때만 사용할 수 있다. <span style="color:rgb(125, 125, 125)">(반대상황은 오류)</span>

```cpp title:정적바인딩강제 hl:17,20
class Base { 
public:
	void show() {
		cout << "Base::show()" << endl;
	}
};

class Derived : public Base {
public:
	void show() {
		cout << "Derived::show()" << endl;
	}
};

int main() {
	Derived derived;
	derived.Base::show();//출력: Base::show()

	Base* pBase = &derived;
	pBase->Derived::show(); // 오류
}
```