컴파일러는 가상 함수를 만나면 런타임 까지 바인딩을 미룬다.
<span style="color:rgb(255, 207, 61)">런타임 중에 객체타입에 맞는 가상 함수가 호출</span>된다.

이러한 이유는 가상 함수가 상속을 바탕으로 한다는 특성 때문이다.
객체는 런타임 중 여러 파생 클래스 객체로 동적으로 변할 수 있기에 컴파일 시간에는 객체의 타입을 확정적으로 알지 못한다.<span style="color:rgb(255, 207, 61)">(다형성)</span>

하여 객체의 타입이 확실해 지는 런타임까지 바인딩을 미루는 것이다.

---
### 대상
가상 함수 & 객체 타입이 명시적이지 않은 함수
- 사용자의 입력을 받거나 동적으로 객체 타입이 바뀌는 경우
- 함수의 반환타입으로 어떤 객체 타입이 반환될 지 알 수 없는 경우
- 동적으로 변하는 객체 타입

### 예외 대상
##### 1. 명시적으로 객체 타입이 확정된 함수
>__*<span style="color:rgb(255, 82, 82)">주의</span>*__
>이는 컴파일러가 상황에 따라 동적으로 바인딩할 수도, 정적으로 바인딩할 수도 있다. 무조건적으로 정적 바인딩을 하지 않는다.

<span style="color:rgb(128, 202, 255)">line12-13</span> : `Base* base = new Derived;`의 경우 컴파일 시간에 `base`의 타입이 무엇인지 확정적으로 알 수 있다. 

컴파일러는 `base->show()`가 가상 함수이지만 업캐스팅을 통해 `Derived`의 `show()`를 실행해야 한다는걸 알기에 컴파일 시간에 함수를 확정지을 수 있다. 

<span style="color:rgb(128, 202, 255)">line15-16</span> : `derived->Base::show();`의 경우 `derived`의 타입이 어떻던 간에 범위지정연산자로 `Base::show()`를 실행하라고 명시적으로 알려주었기에 가상함수임에도 컴파일러는 컴파일 중에 함수를 확정지을 수 있다.
```cpp title:동적바인딩예외1 hl:12-13,15-16
class Base{  
public:
	virtual void show(){ cout << "base" << endl; } //가상 함수
};

class Derived : public Base{
public:
	virtual void show() override{ cout << "derived" << endl; } //오버라이딩
};

int main(){
	Base* base = new Derived();
	base->show(); //출력: derived
	
	Derived* derived = new Derived();
	derived->Base::show(); //출력: base
	
	delete base;
	delete derived;
}
```
 	
##### 2. 객체타입이 명시적인 경우 + final 키워드가 붙은 가상 함수
이는 객체타입이 명시적인 상황인데 해당 객체가 가지고 있는 가상함수에 final 키워드가 붙어있는 경우를 말한다.

객체타입이 명시적인 경우는 확정적으로 정적 바인딩을 하지 않지만, 이 경우 확정적으로 컴파일러가 정적 바인딩을 할 수 있다.

<span style="color:rgb(128, 202, 255)">line22</span> : 컴파일러의 입장에서 `p2->func();`를 보았을 때, 우선 `new Final`로 객체 타입이 명시되어 있는것을 확인할 수 있다.

다음으로 Final::func()의 final 키워드가 붙어있는것을 확인하곤 더이상의 func()를 가지는 파생클래스는 없다는것을 알 수 있으므로 해당 함수를 컴파일 시간에 확정지을 수 있는 것이다.
```cpp title:동적바인딩예외2 hl:13,19,22
class Base { 
public:
    virtual void func() {}
};

class NormalFinal : public Base {
public:
    void func() override {}
};

class Final : public Base {
public:
    void func() final override {} //final overriding
};

int main() {
    // 다형성을 위한 업캐스팅
    Base* p1 = new NormalFinal();
    Base* p2 = new Final();

    p1->func(); // 런타임에 NonFinal::func() 호출
    p2->func(); // 컴파일 중 Final::func()로 바로 연결

    delete p1;
    delete p2;
}
```
