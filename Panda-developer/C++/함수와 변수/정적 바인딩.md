정적 바인딩은 <span style="color:rgb(255, 207, 61)">컴파일 시간에 호출될 함수를 확정</span>하는 것이다. 
프로그램 실행 전 호출할 함수의 메모리 주소를 확정하고, 실행 시 그 주소로 연결한다.

컴파일러는 선언되어 있는 자료형(<span style="color:rgb(255, 207, 61)">포인터/참조 타입</span>)을 보고 바인딩한다.(함수를 결정한다.)

하여, 실행 중 실제로 가리키는 객체의 타입은 무시된다. <span style="color:rgb(125, 125, 125)">(포인터/참조가 아닌 실제 객체를 통해 함수를 호출할 경우, 객체 자신의 함수가 호출된다.)</span>

### 대상
virtual 키워드가 없는 <span style="color:rgb(255, 207, 61)">기본 함수</span>들

---
### 이름 숨김과의 연관성
virtual 키워드가 없는 함수는 자료형(객체 타입_포인터/참조)을 보고 호출할 함수를 확정지으므로 [[이름 숨김]] 현상이 발생하는 것이다.

###### 예시 
1. `ptr->show();`를 컴파일러가 마주했을 때, `Base::show()` 는 virtual 키워드가 없다. 
2. 그럼 컴파일러는 `ptr->show()`의 함수를 ptr타입인 `Base`클래스의 `show()`로 확정하게 된다.
3. 재정의 및 업캐스팅이 되었다 하더라도 `Derived::show()`는 무시된다.

```cpp title:정적바인딩&오버라이딩 hl:3,13
class Base{   
public:
	void show(){} 
};

class Derived : public Base{
public:
	void show(){}
};

int main(){
	Base* ptr = new Derived();
	ptr->show(); //Base의 show호출
}
```

---
### 오버로딩과의 연관성
오버로딩 함수 또한 정적 바인딩에 해당한다.

컴파일 시간에 매개변수의 개수와 타입을 바탕으로 일치하는 함수로 바인딩한다.

하여 오버로딩을 사용하더라도 실행 중에 일치하는 함수를 찾지 않기에 실행속도에 영향을 미치지 않는다.

###### 예시
컴파일러는 컴파일 시, 오버로딩 함수를 마주하더라도 해당 함수와 매개변수가 일치하는 함수를 찾아 확정짓는다.

1. 함수가 인자를 가진다면 인자가 어떤 타입인지 파악한다.
2. 해당 타입과 개수가 일치하는 매개변수를 가지는 함수를 찾아 바인딩한다.
```cpp title:정적바인딩&오버로딩
class Base{ 
public:
	void show(){ cout << "1" << endl; }
	void show(int a){ cout << "2" << endl; }
	void show(char c){ cout << "3" << endl; }
};

int main(){
	Base base;
	base.show(); //츨력: 1
	base.show(2); //출력: 2
	base.show('a'); //출력: 3
}
```
