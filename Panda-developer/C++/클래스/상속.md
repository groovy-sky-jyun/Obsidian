`class 파생클래스명 : 상속접근지정 기본클래스명`

파생 클래스는 상속을 통해 기본 클래스 멤버를 자신의 멤버로 확장시킨다.

### 메모리 구조
컴파일러가 파생 클래스 객체를 생성하면, 기본/파생 클래스 멤버를 전부 가지는 메모리 공간을 할당하게된다.

즉, 파생 클래스 객체는 기본 클래스 객체를 내포하는 형태를 띄게 된다.

<span style="color:rgb(255, 82, 82)">(구조 사진)</span>

>**private 멤버는 상속되지 않는데도 공간을 할당 받는가?**
>
>파생 클래스 메모리 공간은 기본 클래스 메모리 공간을 내포하는 구조를 띄고 있다. 
>
>물론 여기에 기본 클래스의 private 멤버도 메모리 공간을 할당받고 있다.
>
> 상속되지 않는다는 말은 직접적인 접근 권한이 없다는 말과 동일하다. 
> 
>즉, <span style="color:rgb(221, 186, 248)">공간을 차지하고는 있지만 직접적인 접근이 불가능</span>한 것이다.
> 
> 접근을 하기 원한다면 기본 클래스의 public, proteced 멤버 함수를 통해 간접적으로 접근이 가능하다.
---
### 상속 접근 지정자
<span style="color:rgb(255, 207, 61)">기본 클래스의 public, protected 멤버</span>가 <span style="color:rgb(255, 207, 61)">파생 클래스에서 어떤 접근 권한을 가질지 결정</span>한다.

- 어느 상속 접근 지정자를 사용하였든 기본 크랠스의 private 멤버에는 직접적으로 접근할 수 없다.

#### <mark style="background: #FFB86CA6;">public 상속</mark>
기본 클래스의 public, protected 멤버 접근 권한을 그대로 가져온다. 

- public은 파생 클래스 내부와 외부에서 접근이 가능하다.
- protected는 파생 클래스 내부에서 접근이 가능하고, 외부에서는 접근 불가능하다.

#### <mark style="background: #FFB86CA6;">protected 상속</mark>
기본 클래스의 public, protected 멤버 접근 권한을 전부 protected로 변경한다. (public의 접근 권한이 protected로 변경)

- 기본 클래스의 public 멤버를 외부에서 접근할 수 없도록 변경

#### <mark style="background: #FFB86CA6;">private 상속</mark>
기본 클래스의 public, protected 멤버 접근 권한을 전부 private으로 변경한다. 
- 파생클래스와 외부에서 기본 클래스의 모든 멤버에 접근할 수 없도록 변경

#### 상속 접근 지정자 비교
```cpp title:public,protected상속비교 hl:12,23
class Parent {   
	int parent_age;
public:
	//...
	void getParentAge() {
		cout << parent_age << endl;
	}
};

//class Child : protected Parent -> line:22 오류
//class Child : private Parent -> line:22 오류
class Child : public Parent { 
	int child_age;
public:
	//...
	void getChildAge() {
		cout << child_age << endl;
	}
};

int main() {
	Child child;
	child.getParentAge();
}
```
**public 상속**
- Parent 멤버의 public, protected, private 접근 권한 그대로 유지 
- 정상 작동

**protected 상속**
- Parent 멤버의 public 접근 권한이 protected로 변경
- main의 `child.getParentAge()`는 protected에 접근하게 되므로 오류가 발생

**private 상속**
- Parent 멤버의 public, protected 접근 권한이 private로 변경
- main의 `child.getParentAge()`는 private에 접근하게 되므로 오류가 발생

---
### 업 캐스팅
파생 클래스 포인터를 기본 클래스 포인터로 가리키는 것을 말한다.

즉, <span style="color:rgb(255, 207, 61)">파생 클래스 객체를 기본 클래스 객체처럼</span> 다룰 수 있게 한다.

##### 업 캐스팅된 파생 클래스 포인터의 접근 권한
- 기본 클래스의 public 멤버만 접근할 수 있다.
	- protected 멤버는 클래스 외부에서 접근 불가능
- 파생 클래스의 public 멤버에 접근할 수 없다.

```cpp title:Up-casting hl:24-26
class Parent {    
	int parent_age;
public: 
	//...
	void getParentAge(); 
};

class Child : public Parent {
	int child_age;
public:
	//...
	void getChildAge();
};

int main() {
	Child child;
	Child* pChild = &child;
	pChild->getParentAge();
	pChild->getChildAge();

	// 업 캐스팅
	// 기본 클래스 public 멤버만 접근 가능
	// 파생 클래스 public 멤버 접근 불가능
	Parent* pParent = pChild; 
	pParent->getParentAge();
	pParent->getChildAge(); //오류
}
```
line:26에서는 오류가 발생하는데 그 이유는 업 캐스팅 된 파생 클래스 포인터가 파생 클래스 pubilc 멤버에 접근하려 해서이다.

Parent 타입은 Child 멤버에 대해 알지 못한다. 하여 Parent에서 getChildAge() 함수를 찾지 못했으므로 오류가 발생한다.

##### 사용 예시
<span style="color:rgb(255, 207, 61)">인터페이스를 통해 여러 객체를 동일하게 다룰 때</span> 사용된다.

예로 Inventory 클래스에서 다양한 무기, 방어구, 포션 등을 Item 이라는 기본 클래스 포인터 배열에 담고 관리하는 상황에 사용할 수 있다.
```cpp
vector<Item*> items;
items.push_back(new Weapon());
items.push_back(new DefensiveGear());
items.push_back(new Potion());
```

### 다운 캐스팅
기본 클래스 포인터가 가리키는 객체를 파생 클래스의 포인터로 가리키는 것을 말한다.

즉, <span style="color:rgb(255, 207, 61)">기본 클래스 객체를 파생 클래스 객체처럼</span> 다룰 수 있게 한다.

기본 클래스는 하나이지만 파생 클래스는 여러개가 될 수 있다. (자식 클래스는 여러개 가질 수 있다.)

그래서 다운 캐스팅을 할 경우 반드시 <span style="color:rgb(255, 207, 61)">명시적으로 강제 타입 변환</span>을 해주어야 한다.

##### 다운 캐스팅된 기본 클래스 포인터의 접근 권한
- 기본/파생 클래스의 public 멤버에 접근할 수 있다.

```cpp title:Down-casting hl:21,23
class Parent { 
	int parent_age;
public:
	//...
	void getParentAge();
};

class Child : public Parent {
	int child_age;
public:
	//...
	void getChildAge();
};

int main() {
	Parent parent;
	Parent* pParent = &parent;
	pParent->getParentAge();

	// 다운 캐스팅
	Child* pChild = (Child*)pParent; // 강제 타입 변환
	pChild->getParentAge();
	pChild->getChildAge(); // 쓰레기값
}
```
line:26에서 오류가 발생하진 않지만 쓰레기값이 출력되는것을 볼 수 있다.

그 이유는 다운 캐스팅이 파생 클래스의 메모리 주소를 할당해주진 않기 때문이다.

기본 클래스가 다운 캐스팅 되어도 가지는 메모리 공간은 기본 클래스 크기 그대로이다. (변화 x) 

그런데 값을 가지지 않는 파생 클래스 멤버에 접근하고 있으니 쓰레기값이 출력되는 것이다.

이는 심한 경우 프로그램이 충돌하여 비정상 종료를 일으킬 수도 있다.

##### 사용 예시
인터페이스에서 특정 객체의 고유한 기능에 접근할 때 사용된다.

*업 캐스팅 사용 예시*의 Item 배열에서 특정 아이템이 Weapon인지 확인하고 Weapon에만 존재하는 함수를 호출하는 상황
```cpp
void processWeapon(Item* item){
	//다운 캐스팅
	Weapon* weapon = (Weapon*)item;
	if(weapon){
		//weapon에만 존재하는 함수 호출
	}
}
```

<br>

>#### 업 캐스팅과 다운 캐스팅이 포인터로만 가능한 이유
>업/다운 캐스팅은 메모리 주소의 타입만 변경할 뿐, 실제 객체의 메모리 크기나 구조에는 영향을 주지 않는다.
>
>일반 객체는 객체 자체의 값을 가지는 메모리 공간인데 이를 업/다운 캐스팅 해버리면 slicing 문제가 발생한다.
>
>즉, 기본 클래스와 파생 클래스의 공간 크기 차이로 인해 데이터 손실이 발생할 수 있으므로 일반 객체의 타입 변환은 허용되지 않는다.