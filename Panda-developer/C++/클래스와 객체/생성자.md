객체가 생성될 때 한번 실행되는 멤버 함수이다.
객체를 초기화 하기 위해 사용된다.

### 생성자 오버로딩
생성자는 <span style="color:rgb(255, 207, 61)">매개타입을 다르게</span> 하면, 한 클래스에 여러개의 생성자를 만들 수 있다.

단, 객체가 생성될 때 실행되는 생성자는 하나이다. 

```cpp title:생성자오버로딩 hl:9,14
class Circle{   
public: 
	Circle();
	Circle(int r);
private:
	int radius;
};
 
Circle::Circle(){
	radius = 1;
	cout << "반지름: " << radius << endl;
}

Circle::Circle(int r){
	radius = r;
	cout << "반지름: " << radius << endl;
}

int main(){
	Circle donut; //반지름: 1
	Circle pizza(30); //반지름: 30
}
```

### 위임 생성자
<span style="color:rgb(255, 207, 61)">자신의 초기화 작업 일부 또는 전체를 다른 생성자에게 위임</span>하는 생성자를 위임 생성자라고 한다.

생성자는 #초기화리스트 <span style="color:rgb(125, 125, 125)">*(다음 단락에 설명)*</span> 를 통해 작업을 위임할 수 있다. 
- **위임 생성자** : 다른 생성자에게 작업 위임
- **타겟 생성자** : 위임 당하는 생성자

위의 코드<span style="color:rgb(125, 125, 125)">(*생성자중복*)</span>를 보면 두개의 생성자가 하는 역할이 같아 코드가 중복되는것을 볼 수 있다. 

중복되는 코드를 타겟 생성자에 작성하고, <span style="color:rgb(255, 207, 61)">위임 생성자를 타겟 생성자로 초기화</span>하는 방식으로 코드 중복을 없앨 수 있다.
```cpp title:위임생성자 hl:1
Circle::Circle() : Circle(1) { } //위임 생성자

Circle::Circle(int r) : radius(r) { //타겟 생성자
	cout << "반지름: " << radius << endl;
}
 
int main(){
	Circle circle; //반지름: 1
}
```
>##### 위임생성자가 {본문}에서 타겟 생성자를 호출하지 않는 이유 
>**궁금증**
>#초기화리스트 대신 `Circle() { Circle(1); }`처럼 본문에서 타겟 생성자를 호출하지 않는 이유가 뭘까?
>
>**답변**
>{본문}에서 생성자를 호출하면 <span style="color:rgb(221, 186, 248)">임시 객체를 생성하고 본문이 끝남과 동시에 소멸된다.</span> 
>
>즉, `main에서 생성된 circle 객체`와 `Circle() 내부에서 생성된 임시 객체`는 서로 다른 객체인 것이다. 그로 인해 main에서 생성된 circle 객체는 radius값을 전달받지 못했으므로 쓰레기 값을 가지게 된다.<span style="color:rgb(125, 125, 125)">*(초기화리스트를 사용하지 않을 경우, 생성시 쓰레기 값으로 초기화됨)*</span>
>```cpp title:잘못된위임생성자
>Circle::Circle(){
>	Circle(1); //임시 객체 생성 후 소멸
>}
>
>Circle::Circle(int r) {
>	radius = r;
>}
>
>int main() {
>	Circle circle;
>	cout << circle.getRadius() << endl; //쓰레기값
>}
>```

---

### 범위 지정 연산자
생성자 구현부 코드를 보면 `Circle::Circle(){}` 처럼 작성되어 있다. 
여기서 `::` 을 범위 지정 연산자라고 한다.

<span style="color:rgb(255, 207, 61)">클래스에 속한 멤버 함수를 외부에서 정의</span>할 때 해당 연산자를 사용한다. 

`a::b`라고 했을 때, <span style="color:rgb(255, 207, 61)">a클래스 범위 안에 있는 b멤버함수를 정의</span>한다는 뜻이다.

### #초기화리스트
생성자 구현부 코드 `Circle::Circle(int r) : radius(r) {}`에서 `:`를 통해 radius 를 초기화 해주고 있는것을 볼 수 있다.

`:`는 초기화 리스트 이다.
이는 말 그대로 <span style="color:rgb(255, 207, 61)">객체가 생성됨과 동시에 초기화</span>할 값들의 리스트이다.

>##### 대입연산자 대신 초기화리스트를 사용해야 하는 이유 
>**대입 연산자로 멤버 변수 초기화 과정**
>1. 객체가 생성되면서 멤버 변수는 <span style="color:rgb(221, 186, 248)">쓰레기 값으로 초기화</span>된다.
>2. 대입 연산자를 통해 멤버 변수에 값을 넘겨준다.
>
>**발생하는 문제**
>- 2단계를 거처야 하므로 비효율적이다.
>- <span style="color:rgb(221, 186, 248)">const나 참조변수는 대입연산자를 통해 초기화 할 수 없다. </span>
>```cpp title:초기화리스트사용x
>Circle::Circle(int r){ 
>	cout << "대입 전 반지름: " << radius << endl;
>	radius = r;
>	cout << "대입 후 반지름: " << radius << endl;
>} 
>
>int main(){
>	Circle circle(20);
>	// 대입 전 반지름: 쓰레기 값
>	// 대입 후 반지름: 20
>}
>```
>
>**초기화 리스트로 멤버 변수 초기화**
>객체 생성과 동시에 값을 초기화 시킬 수 있으므로 효율적이며, const와 참조 변수 또한 원하는 값으로 초기화 할 수 있게된다.
>```cpp title:초기화리스트사용o
>Circle::Circle(int a, int b) : width(a), height(b) {
>	cout << "width: " << width << ", height: " << height << endl;
>}  
>
>int main(){	
>	Circle circle2(1,2); // width: 1, height: 2
>}
>```

---

### 생성자 사용 시 주의할 점
컴파일러는 생성자가 정의되어있지 않더라도 기본 생성자를 자동 삽입 해주므로 오류가 발생하지 않는다.

허나, <span style="color:rgb(255, 207, 61)">생성자가 하나라도 선언되어 있다면 컴파일러는 기본 생성자를 자동 삽입하지 않는다.</span>
```cpp title:기본생성자자동삽입x
class Circle{
public:
	int radius;
	Circle(int r);
	...
};

int main(){
	Circle circle; //기본 생성자가 없으므로 컴파일 오류
}
```