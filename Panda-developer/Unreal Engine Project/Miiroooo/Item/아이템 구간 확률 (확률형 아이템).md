### **변경 전** 랜덤 아이템 구현

기존에는 랜덤 아이템을 구현할 때, 아이템마다 최대로 나올 수 있는 개수를 지정해두었다. 

플레이어가 아이템을 뽑으면 그 아이템의 최대 개수가 줄어드는 방식으로 구현하였다.

아래 예시를 들어 보겠다.

처음에 각각의 아이템들은 최대로 뽑을 수 있는 개수에 대한 정보를 가지고 있다.

플레이어가 C-A-C-B-C 순서로 아이템을 뽑았다고 하자. 

그럼 플레이어가 뽑을 수 있는 아이템의 수는 아래 표처럼 변경된다.

그럼 이제 플레이어는 아무리 뽑아도 C아이템을 더 뽑을 수는 없다.

![[Pasted image 20250306232238.png|아이템 최대 개수 변경 예시]]



#### 장점

- 아이템을 플레이어가 골고루 획들할 수 있다.

위의 예시로 들자면 최대 18번의 뽑기를 진행하면 플레이어는 **무조건** 100% 모든 종류의 아이템을 얻을 수 있다.

#### 단점

- 아이템이 추가될 때마다 확률을 조절하기 위해 전체 아이템 개수 조절이 필요하다 

이 방식은 확률보다는 개수에 초점을 맞춘것이기에 확률을 조절하기 위해서는 아이템전체의 개수를 조절하기 위한 계산을 해야하는 번거로움이 발생한다. 하여 아이템을 추가할수록 개수를 조절하기가 복잡해진다.

---

### **변경 후** 랜덤 아이템 구현

구간 확률 아이템 뽑기 형태로 변경하였다.

이는 하나의 전체 구간이 있을 때, 각 아이템들은 자신의 확률값만큼의 범위를 자기 자신의 범위로 가진다.

전체 구간이 100까지 있다고 했을 때, E아이템의 확률값이 40%라면 E아이템은 1~40까지의 범위를 가지게 되는 것이다.

아래 그림으로 예시를 들어보겠다.

![[Pasted image 20250306232255.png|구간 확률 예시]]

각 아이템들은 각각 A-5%, B-15%, C-15%, D-25%, E-40% 확률을 가진다.

전체구간을 0~99까지라고 했을 때, A는 95~99의 영역을 가지게 되고, E는 0~39의 영역을 가지게 된다.

이때, 해당 영역의 위치는 내가 지정해주는 것이지 무조건 이대로 해야하는것이 아니다.

A가 0~4, 85~89 등의 영역을 가질수도 있는것이다. 이는 본인의 마음대로 지정해주면 된다.

이제 랜덤 아이템하나를 뽑아보자.

0~99까지의 구간 중 랜덤 값 하나를 뽑았을 때 72라는 숫자가 나왔다.

72가 속해있는 곳은 C아이템의 영역인 것을 확인할 수 있다.

그럼 랜덤 아이템은 C가 반환되는 것이다.

#### 장점

- 아이템이 추가됐을 때 확률을 조절하기 쉽다.
- 보정값을 추가로 구현하기 용이하다.

#### 코드 구현

```cpp
// UItemComponent.h
UPROPERTY(VisibleAnywhere)
TMap<FName, float> UsableItemProbabilistic; //아이템 이름과 확률(0.xx)

// UItemCompoent.cpp
FName UItemComponent::GetProbabilisticItem()
{
	// ProbabilitySum : 전체 아이템 확률 합
	if (ProbabilitySum > 0.f)
	{
		//  (0 ~ ProbabilitySum-1) 중 랜덤값 뽑기
		int32 RandValue = FMath::RandRange(0.f, (ProbabilitySum * 100) - 1);
		
		// 그 구간에 맞는 확률을 가진 아이템을 찾아 반환
		int32 Panel = 0.f;
		for (auto& UsableItem : UsableItemProbabilistic)
		{
			Panel += UsableItem.Value * 100;
			if (RandValue < Panel)
			{
				return UsableItem.Key;
			}
		}
	}
	return EItemName();
}
```

아이템 확률을 소수점으로 지정해줬다. ex)20% -> 0.02f

하여 UssableItem.Value*100을 통해 int형으로 변경해주는 것이다.

for문을 보면 랜덤값이 처음 아이템 영역에 해당하지 않는다면 다음 영역에 포함되는지 확인하고, 또 해당되지 않는다면 그 다음 영역에 포함되는지 확인하는 작업을 반복적으로 수행하고 있다.