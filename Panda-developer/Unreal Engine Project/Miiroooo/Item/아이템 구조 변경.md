아이템 관련 기능을 구현하며 늘 아이템 클래스 구조가 마음에 걸렸었다.

변경하고자 하기엔 이미 한번 변경한 구조였기에, 내 머리속에서 나올 수 있는 최대한의 구조라고 생각하고 이대로 사용해왔다.

문제는 미처 예상치 못한곳에서 발생했다.

기존에는 플레이어가 1번 키를 눌러 아이템을 사용하면 플레이어가 아이템을 1개 이상 소유하고 있을 시 무조건적으로 아이템이 사용되었다. 그러나 뒤늦게 예외 상황들이 생각난 것이다.

> 예외상황  
> - 포션의 경우, 플레이어의 Hp가 이미 Max면 사용하지 못한다.  
> - 스프레이의 경우, 플레이어가 벽을 바라보고 있지 않다면 사용하지 못한다.

이러한 예외상황들을 구현하려면 현재 구조로는 순환참조가 계속해서 발생할 뿐이였다. 

이를 해결하기 위해 구조 변환이 필요하였고, 인강에서 사용하는 Game Instance를 프로젝트에 사용해보자는 생각이 떠올라 실행하였다.

![[Pasted image 20250306231848.png|아이템 관련 클래스 구조 변화]]

---

### 아이템 클래스

#### **변경 전** 아이템 클래스 구조

![[Pasted image 20250306231903.png|변경 전 아이템 클래스 구조]]

아이템 클래스 구조를 살펴보면 엄청 단순하게 구현한것을 볼 수 있다.

모든 아이템은 Basic Item Class 를 상속하고 있다.

Basic Item에서는 공통적으로 구현되어야 하는 UseItem() 함수를 가상함수로 선언하여 모든 자식 클래스들이 해당 함수를 오버라이딩하도록 유도하고 있다.

이 구조는 문제점이 있다. 미로 프로젝트에서는 아이템을 2종류(플레이어가 착용하는 아이템, 사용하는 아이템)로 구분할 수 있다. 허나, 이를 고려하지 않은 구조이기에 추후에 아이템 타입에 따른 다른 동작을 구현할 때 문제가 발생할 수 있다.

또한 다른 클래스에서 해당 객체를 참조할 때 해당 객체가 어떤 아이템 타입인지 분간하기가 어려운 문제를 가지고 있다.

#### **변경 후** 아이템 클래스 구조

![[Pasted image 20250306231924.png|변경 후 아이템 클래스 구조]]



미로 프로젝트의 아이템 종류를 고려하여 클래스를 세분화하였다.

장비와 관련된 함수들은 Equipment Item에서 관리하고, 사용아이템과 관련된 함수들은 Usable Item에서 관리한다.

즉, Equipment Item와 Usable Item이 인터페이스와도 같은 역할을 하게 되는 것이다.

Base Item 클래스로 Equipment Item와 Usable Item을 묶어주는 일이 필요할까 고민하였는데, 플레이어가 특정 객체와 Overlap되었을 때 해당 객체가 Item 객체인지 확인이 필요하기에 묶어주는게 좋다고 판단하였다.

---

### 플레이어가 소유하고 있는 아이템 관리 클래스

#### **변경 전** Has Items The Player 클래스 구조

![[Pasted image 20250306231938.png|변경 전 Has Items The Player 클래스 구조]]



지금 생각하면 참 안타까운 구조이다.

Inentory Component는 플레이어가 소지하고 있는 아이템을 관리할 뿐만 아니라 아이템과 관련된 모든 상호작용들을 관리하고 있다. 이 두 기능을 분리하지 않고 한 클래스에 집어 넣었기에 기능이 이것저것 섞여 너무 복잡하고, 여기저기서 참조가 필요하기에 순환참조가 발생하기 좋았다.(실제로 개발할때 순환참조 문제로 애를 먹었다.) 

가장 큰 문제점은 외부 클래스에서 Inventory Component에 접근할 때다. 

Inventory Component는 플레이어가 소지하고 있는 아이템을 관리하고 있기에 싱글톤과 같은 역할을 해야했다. 한마디로 외부 어느 클래스에서 접근을 하더라도 결과값이 같아야 했다. 하지만 해당 클래스는 싱글톤이 아니기에 일치하는 결과값을 얻기위해서는 다음과 같은 과정이 필요하였다. 

```cpp
// 1) Player Character 클래스를 변수로 생성한다.
APlayerCharacter* Player;

// 2) 변수 Player Character에서 Inventory Component Instance에 접근한다.
AInventoryComponent* InventoryComponent = Player->GetInventoryComponent();
```

이렇게 하지 않고 새로 객체를 생성하거나 참조하면 새로운 Inventory Component의 Instance에 접근하는 것이기에 결과값이 달라지게 된다. 즉, 외부 클래스에서 Inventory Component를 참조하고 싶으면 2개(PlayerCharacter, InventoryComponent)의 클래스 참조가 필요하게 되는 것이다. 참조는 적을 수록 좋은데 오히려 필요없는 참조까지 하게된 것이다.

#### **변경 후** Has Items The Player 클래스 구조

![[Pasted image 20250306231955.png|변경 후 Has Items The Player 클래스 구조]]



플레이어가 소유하고 있는 아이템에 대한 정보는 Game Instance에서 관리해준다. Game Instance는 하나의 Level에 한개만 존재하기에 공유해야하는 영구 데이터를 관리하기에 좋다. Game Instance에 대한 자세한건 나중에 게시글로 정리하겠다. 이렇게 Inventory Component와 기능을 분리하여 참조문제를 해결하였다.

---

### 추가 예정

아이템 상호작용과 관련된 컴포넌트는 추가 수정사항이 생길 수 있기에 기능 구현이 끝나고 추가하도록 하겠다.